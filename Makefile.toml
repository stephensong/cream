[config]
default_to_workspace = false

[tasks.build]
description = "Build all contracts, delegate, and UI"
dependencies = ["build-contracts", "build-delegate", "build-ui"]

[tasks.build-contracts]
description = "Build WASM contracts"
dependencies = ["build-directory-contract", "build-storefront-contract", "build-user-contract"]

[tasks.build-directory-contract]
description = "Build directory contract WASM"
command = "cargo"
args = ["build", "-p", "cream-directory-contract", "--target", "wasm32-unknown-unknown", "--release", "--features", "contract"]

[tasks.build-storefront-contract]
description = "Build storefront contract WASM"
command = "cargo"
args = ["build", "-p", "cream-storefront-contract", "--target", "wasm32-unknown-unknown", "--release", "--features", "contract"]

[tasks.build-user-contract]
description = "Build user contract WASM"
command = "cargo"
args = ["build", "-p", "cream-user-contract", "--target", "wasm32-unknown-unknown", "--release", "--features", "contract"]

[tasks.build-contracts-dev]
description = "Build WASM contracts with dev feature (no signature checks)"
dependencies = ["build-directory-contract-dev", "build-storefront-contract-dev", "build-user-contract-dev"]

[tasks.build-directory-contract-dev]
description = "Build directory contract WASM with dev feature"
command = "cargo"
args = ["build", "-p", "cream-directory-contract", "--target", "wasm32-unknown-unknown", "--release", "--features", "contract,dev"]

[tasks.build-storefront-contract-dev]
description = "Build storefront contract WASM with dev feature"
command = "cargo"
args = ["build", "-p", "cream-storefront-contract", "--target", "wasm32-unknown-unknown", "--release", "--features", "contract,dev"]

[tasks.build-user-contract-dev]
description = "Build user contract WASM with dev feature"
command = "cargo"
args = ["build", "-p", "cream-user-contract", "--target", "wasm32-unknown-unknown", "--release", "--features", "contract,dev"]

[tasks.build-delegate]
description = "Build CREAM delegate"
command = "cargo"
args = ["build", "-p", "cream-delegate", "--release"]

[tasks.build-ui]
description = "Build UI with dx"
cwd = "ui"
command = "dx"
args = ["build", "--release"]

[tasks.dev]
description = "Run UI development server"
cwd = "ui"
command = "dx"
args = ["serve"]

[tasks.local-network]
description = "Start local Freenet network (1 gateway + 2 nodes)"
script = ["cd ${FREENET_CORE}/scripts && unset MAKEFLAGS && export N_GATEWAYS=1 N_NODES=2 FREENET_CORE_PATH=${FREENET_CORE}/crates/core && make -e -f local-network.mk setup start"]
[tasks.local-network.env]
FREENET_CORE = { value = "${HOME}/dev/freenet-core", condition = { env_not_set = ["FREENET_CORE"] } }

[tasks.local-network-stop]
description = "Stop local Freenet network"
script = ["cd ${FREENET_CORE}/scripts && unset MAKEFLAGS && export FREENET_CORE_PATH=${FREENET_CORE}/crates/core && make -e -f local-network.mk stop"]
[tasks.local-network-stop.env]
FREENET_CORE = { value = "${HOME}/dev/freenet-core", condition = { env_not_set = ["FREENET_CORE"] } }

[tasks.dev-android]
description = "Run UI dev server for Android with remote Freenet node"
dependencies = ["build-contracts-dev"]
cwd = "ui"
command = "dx"
args = ["serve", "--platform", "android", "--features", "mobile", "--no-default-features"]
[tasks.dev-android.env]
CREAM_NODE_URL = { value = "${CREAM_NODE_URL}", condition = { env_set = ["CREAM_NODE_URL"] } }

[tasks.dev-ios]
description = "Run UI dev server for iOS with remote Freenet node"
dependencies = ["build-contracts-dev"]
cwd = "ui"
command = "dx"
args = ["serve", "--platform", "ios", "--features", "mobile", "--no-default-features"]
[tasks.dev-ios.env]
CREAM_NODE_URL = { value = "${CREAM_NODE_URL}", condition = { env_set = ["CREAM_NODE_URL"] } }

[tasks.build-android]
description = "Build release APK for Android"
dependencies = ["build-contracts"]
cwd = "ui"
command = "dx"
args = ["build", "--release", "--platform", "android", "--features", "mobile", "--no-default-features"]
[tasks.build-android.env]
CREAM_NODE_URL = { value = "${CREAM_NODE_URL}", condition = { env_set = ["CREAM_NODE_URL"] } }

[tasks.build-ios]
description = "Build release for iOS"
dependencies = ["build-contracts"]
cwd = "ui"
command = "dx"
args = ["build", "--release", "--platform", "ios", "--features", "mobile", "--no-default-features"]
[tasks.build-ios.env]
CREAM_NODE_URL = { value = "${CREAM_NODE_URL}", condition = { env_set = ["CREAM_NODE_URL"] } }

[tasks.reset-node]
description = "Stop Freenet node, wipe contract state, and restart (dev only)"
script = [
    "pkill -9 -x freenet || true",
    "sleep 2",
    "rm -rf ${HOME}/.local/share/freenet/db ${HOME}/.cache/freenet/gw1/db",
    "echo 'Node state cleared. Restarting...'",
    "nohup freenet local --ws-api-port 3001 > /dev/null 2>&1 &",
    "sleep 1",
    "echo 'Freenet node restarted on port 3001'",
]

[tasks.test]
description = "Run all tests"
command = "cargo"
args = ["test", "--workspace"]

[tasks.test-node]
description = "Build contracts, reset multi-node network, and run integration tests"
dependencies = ["build-contracts-dev", "reset-network"]
command = "cargo"
args = ["test", "-p", "cream-node-integration", "--features", "node-tests", "--", "--nocapture"]

[tasks.kill-stale]
description = "Kill stale dx serve, freenet, guardian, and cargo-make processes from previous fixture runs"
script = [
    '''
    set -euo pipefail
    pkill -f "dx serve" 2>/dev/null || true
    pkill -f "cream-guardian" 2>/dev/null || true
    # Kill stale cargo-make fixture processes but not the current one ($$=shell, PPID chain)
    CURRENT_CARGO_MAKE=$(ps -o ppid= -p $$ 2>/dev/null | tr -d ' ')
    for pid in $(pgrep -f "cargo-make make fixture" 2>/dev/null); do
        if [ "$pid" != "$CURRENT_CARGO_MAKE" ] && [ "$pid" != "$$" ]; then
            kill "$pid" 2>/dev/null || true
        fi
    done
    sleep 2
    echo "Stale processes cleaned up"
    '''
]

# ─── Guardian Daemon ──────────────────────────────────────────────────────

[tasks.build-guardian]
description = "Build FROST guardian daemon"
command = "cargo"
args = ["build", "-p", "cream-guardian"]

[tasks.start-guardians]
description = "Start 3 FROST guardian daemons with DKG on ports 3010/3011/3012, connected to co-located Freenet nodes"
dependencies = ["build-guardian"]
script = [
    '''
    set -euo pipefail
    PIDS_DIR="${HOME}/.cache/freenet/pids"
    LOGS_DIR="${HOME}/.cache/freenet/logs"
    KEYS_BASE="${HOME}/.cache/freenet"
    mkdir -p "${PIDS_DIR}" "${LOGS_DIR}"

    GUARDIAN_BIN="./target/debug/cream-guardian"

    # Clear previous DKG keys so a fresh ceremony runs
    rm -rf "${KEYS_BASE}/guardian-1" "${KEYS_BASE}/guardian-2" "${KEYS_BASE}/guardian-3"

    # Peer URLs for each guardian (each gets the other two)
    PEERS_1="http://localhost:3011,http://localhost:3012"
    PEERS_2="http://localhost:3010,http://localhost:3012"
    PEERS_3="http://localhost:3010,http://localhost:3011"

    # Co-located Freenet node URLs (guardian i → ws:3004+i)
    NODE_URL_1="ws://localhost:3005/v1/contract/command?encodingProtocol=native"
    NODE_URL_2="ws://localhost:3006/v1/contract/command?encodingProtocol=native"
    NODE_URL_3="ws://localhost:3007/v1/contract/command?encodingProtocol=native"

    for i in 1 2 3; do
        PORT=$((3009 + i))
        eval "PEERS=\$PEERS_${i}"
        eval "NODE_URL=\$NODE_URL_${i}"
        echo "Starting guardian ${i} on port ${PORT} with peers ${PEERS} and node ${NODE_URL}..."
        : > "${LOGS_DIR}/guardian-${i}.log"
        nohup "${GUARDIAN_BIN}" --share-index "${i}" --port "${PORT}" --peers "${PEERS}" \
            --node-url "${NODE_URL}" \
            >> "${LOGS_DIR}/guardian-${i}.log" 2>&1 &
        echo $! > "${PIDS_DIR}/guardian-${i}.pid"
    done

    # Wait for all 3 to be ready (DKG) and connected to their nodes
    for i in 1 2 3; do
        PORT=$((3009 + i))
        for attempt in $(seq 1 60); do
            HEALTH=$(curl -s "http://localhost:${PORT}/health" 2>/dev/null || echo "")
            if echo "${HEALTH}" | grep -q '"ready":true' && echo "${HEALTH}" | grep -q '"node_connected":true'; then
                echo "Guardian ${i} ready and node-connected on port ${PORT}"
                break
            fi
            if [ "${attempt}" -eq 60 ]; then
                echo "ERROR: Guardian ${i} failed to become ready/connected on port ${PORT}"
                echo "Last health: ${HEALTH}"
                cat "${LOGS_DIR}/guardian-${i}.log" 2>/dev/null | tail -20
                exit 1
            fi
            sleep 1
        done
    done

    # Save the public key for reference
    curl -s "http://localhost:3010/public-key" > "${KEYS_BASE}/guardian-public-key.json"
    echo "All 3 guardians ready (DKG complete, nodes connected, public key saved)"
    '''
]

[tasks.dkg]
description = "Run standalone DKG ceremony: start 3 guardians, wait for DKG, save public key, stop"
dependencies = ["build-guardian"]
script = [
    '''
    set -euo pipefail
    KEYS_BASE="${HOME}/.cache/freenet"
    LOGS_DIR="${KEYS_BASE}/logs"
    mkdir -p "${LOGS_DIR}"

    GUARDIAN_BIN="./target/debug/cream-guardian"

    # Clear previous DKG keys
    rm -rf "${KEYS_BASE}/guardian-1" "${KEYS_BASE}/guardian-2" "${KEYS_BASE}/guardian-3"

    PEERS_1="http://localhost:3011,http://localhost:3012"
    PEERS_2="http://localhost:3010,http://localhost:3012"
    PEERS_3="http://localhost:3010,http://localhost:3011"

    PIDS=""
    for i in 1 2 3; do
        PORT=$((3009 + i))
        eval "PEERS=\$PEERS_${i}"
        : > "${LOGS_DIR}/guardian-${i}.log"
        nohup "${GUARDIAN_BIN}" --share-index "${i}" --port "${PORT}" --peers "${PEERS}" \
            >> "${LOGS_DIR}/guardian-${i}.log" 2>&1 &
        PIDS="${PIDS} $!"
    done

    # Wait for DKG to complete on all 3
    for i in 1 2 3; do
        PORT=$((3009 + i))
        for attempt in $(seq 1 30); do
            HEALTH=$(curl -s "http://localhost:${PORT}/health" 2>/dev/null || echo "")
            if echo "${HEALTH}" | grep -q '"ready":true'; then
                echo "Guardian ${i} DKG complete"
                break
            fi
            if [ "${attempt}" -eq 30 ]; then
                echo "ERROR: Guardian ${i} DKG timed out"
                cat "${LOGS_DIR}/guardian-${i}.log" 2>/dev/null | tail -10
                kill ${PIDS} 2>/dev/null || true
                exit 1
            fi
            sleep 1
        done
    done

    # Save public key
    curl -s "http://localhost:3010/public-key" > "${KEYS_BASE}/guardian-public-key.json"
    echo "DKG ceremony complete. Public key saved to ${KEYS_BASE}/guardian-public-key.json"

    # Stop guardians
    kill ${PIDS} 2>/dev/null || true
    echo "Guardians stopped"
    '''
]

[tasks.stop-guardians]
description = "Stop all FROST guardian daemons"
script = [
    '''
    PIDS_DIR="${HOME}/.cache/freenet/pids"
    for i in 1 2 3; do
        pidfile="${PIDS_DIR}/guardian-${i}.pid"
        if [ -f "${pidfile}" ]; then
            kill $(cat "${pidfile}") 2>/dev/null || true
            rm -f "${pidfile}"
        fi
    done
    pkill -f "cream-guardian" 2>/dev/null || true
    echo "Guardians stopped"
    '''
]

[tasks.fixture]
description = "Full manual-testing fixture: build contracts, start network, run tests, start guardians, start rendezvous, launch UI dev server"
dependencies = ["kill-stale", "test-node", "start-guardians", "restart-rendezvous", "tailwind-install", "tailwind-build"]
cwd = "ui"
command = "dx"
args = ["serve"]
[tasks.fixture.env]
CREAM_RENDEZVOUS_URL = "http://localhost:8787"
CREAM_GUARDIAN_URLS = "http://localhost:3010,http://localhost:3011,http://localhost:3012"

[tasks.restart-rendezvous]
description = "Kill any stale wrangler and start fresh rendezvous service on port 8787"
dependencies = ["rendezvous-install"]
script = [
    '''
    set -euo pipefail
    # Kill any existing wrangler processes
    pkill -f "wrangler dev" 2>/dev/null || true
    sleep 1

    cd rendezvous
    nohup npx wrangler dev --port 8787 > /tmp/cream-rendezvous.log 2>&1 &
    echo $! > /tmp/cream-rendezvous.pid

    # Wait for it to be ready
    for i in $(seq 1 15); do
        if curl -s "http://localhost:8787" > /dev/null 2>&1; then
            echo "Rendezvous service ready on port 8787"
            exit 0
        fi
        sleep 1
    done
    echo "Timed out waiting for rendezvous service"
    exit 1
    ''',
]

[tasks.reset-network]
description = "Stop all Freenet processes, wipe state, start multi-node network (1 gateway + 3 nodes + 3 guardian nodes)"
script = [
    '''
    set -euo pipefail
    BASE="${HOME}/.cache/freenet"
    KEYS="${BASE}/keys"
    PIDS="${BASE}/pids"
    LOGS="${BASE}/logs"
    ENV="RUST_BACKTRACE=1 RUST_LOG=info"

    # Stop existing processes (SIGKILL to ensure they die quickly)
    pkill -9 -x freenet 2>/dev/null || true
    sleep 2

    # Wipe node state and stale config (nodes share config-dir, so config.toml conflicts)
    rm -rf "${BASE}/gw1/db" "${BASE}/n1/db" "${BASE}/n2/db" "${BASE}/n3/db"
    rm -rf "${BASE}/g1/db" "${BASE}/g2/db" "${BASE}/g3/db"
    rm -rf "${HOME}/.local/share/freenet/db"
    rm -f "${BASE}/config.toml"
    mkdir -p "${KEYS}" "${PIDS}" "${LOGS}" "${BASE}/gw1" "${BASE}/n1" "${BASE}/n2" "${BASE}/n3"
    mkdir -p "${BASE}/g1" "${BASE}/g2" "${BASE}/g3"

    # Generate X25519 transport keypair if missing
    if [ ! -f "${KEYS}/gw1_private_key.pem" ] || head -1 "${KEYS}/gw1_private_key.pem" | grep -q "BEGIN"; then
        echo "Generating X25519 transport keypair..."
        python3 -c "
from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey
import binascii, os
private_key = X25519PrivateKey.generate()
priv_hex = binascii.hexlify(private_key.private_bytes_raw()).decode()
pub_hex = binascii.hexlify(private_key.public_key().public_bytes_raw()).decode()
print(priv_hex, end='')
open('${KEYS}/gw1_public_key.pem', 'w').write(pub_hex)
" > "${KEYS}/gw1_private_key.pem"
        echo "  Keys written to ${KEYS}/"
    fi

    echo "Starting gateway on ws:3001..."
    : > "${LOGS}/gw1.log"
    nohup env ${ENV} freenet network \
        --skip-load-from-network \
        --config-dir "${BASE}" \
        --is-gateway \
        --ws-api-port 3001 \
        --public-network-address 127.0.0.1 \
        --public-network-port 3101 \
        --data-dir "${BASE}/gw1" \
        --transport-keypair "${KEYS}/gw1_private_key.pem" \
        --network-port 3101 \
        >> "${LOGS}/gw1.log" 2>&1 &
    echo $! > "${PIDS}/gw1.pid"

    # Wait for gateway to be ready (it clobbers gateways.toml on startup)
    for i in $(seq 1 15); do
        if ss -tlnp 2>/dev/null | grep -q ':3001 '; then break; fi
        sleep 1
    done

    # Write gateways.toml AFTER gateway starts (freenet overwrites it during init)
    # Also remove config.toml that the gateway persists (contains is_gateway=true
    # and the gateway's transport_keypair — nodes sharing config-dir would inherit these)
    cat > "${BASE}/gateways.toml" << TOML
[[gateways]]
address = { host_address = "127.0.0.1:3101" }
public_key = "${KEYS}/gw1_public_key.pem"
TOML
    rm -f "${BASE}/config.toml"

    echo "Starting node-1 on ws:3002..."
    : > "${LOGS}/n1.log"
    nohup env ${ENV} freenet network \
        --skip-load-from-network \
        --config-dir "${BASE}" \
        --ws-api-port 3002 \
        --public-network-port 3003 \
        --data-dir "${BASE}/n1" \
        --network-port 3102 \
        >> "${LOGS}/n1.log" 2>&1 &
    echo $! > "${PIDS}/n1.pid"
    sleep 2

    echo "Starting node-2 on ws:3003..."
    : > "${LOGS}/n2.log"
    nohup env ${ENV} freenet network \
        --skip-load-from-network \
        --config-dir "${BASE}" \
        --ws-api-port 3003 \
        --public-network-port 3005 \
        --data-dir "${BASE}/n2" \
        --network-port 3103 \
        >> "${LOGS}/n2.log" 2>&1 &
    echo $! > "${PIDS}/n2.pid"
    sleep 2

    echo "Starting node-3 on ws:3004..."
    : > "${LOGS}/n3.log"
    nohup env ${ENV} freenet network \
        --skip-load-from-network \
        --config-dir "${BASE}" \
        --ws-api-port 3004 \
        --public-network-port 3006 \
        --data-dir "${BASE}/n3" \
        --network-port 3104 \
        >> "${LOGS}/n3.log" 2>&1 &
    echo $! > "${PIDS}/n3.pid"
    sleep 2

    # Guardian co-located Freenet nodes (g1, g2, g3)
    echo "Starting guardian node g1 on ws:3005..."
    : > "${LOGS}/g1.log"
    nohup env ${ENV} freenet network \
        --skip-load-from-network \
        --config-dir "${BASE}" \
        --ws-api-port 3005 \
        --public-network-port 3105 \
        --data-dir "${BASE}/g1" \
        --network-port 3105 \
        >> "${LOGS}/g1.log" 2>&1 &
    echo $! > "${PIDS}/g1.pid"
    sleep 2

    echo "Starting guardian node g2 on ws:3006..."
    : > "${LOGS}/g2.log"
    nohup env ${ENV} freenet network \
        --skip-load-from-network \
        --config-dir "${BASE}" \
        --ws-api-port 3006 \
        --public-network-port 3106 \
        --data-dir "${BASE}/g2" \
        --network-port 3106 \
        >> "${LOGS}/g2.log" 2>&1 &
    echo $! > "${PIDS}/g2.pid"
    sleep 2

    echo "Starting guardian node g3 on ws:3007..."
    : > "${LOGS}/g3.log"
    nohup env ${ENV} freenet network \
        --skip-load-from-network \
        --config-dir "${BASE}" \
        --ws-api-port 3007 \
        --public-network-port 3107 \
        --data-dir "${BASE}/g3" \
        --network-port 3107 \
        >> "${LOGS}/g3.log" 2>&1 &
    echo $! > "${PIDS}/g3.pid"
    sleep 2

    # Verify all seven are running
    RUNNING=0
    for port in 3001 3002 3003 3004 3005 3006 3007; do
        if ss -tlnp 2>/dev/null | grep -q ":${port} "; then
            RUNNING=$((RUNNING + 1))
        else
            echo "WARNING: no listener on port ${port}"
            case ${port} in
                3001) tail -5 "${LOGS}/gw1.log" 2>/dev/null ;;
                3002) tail -5 "${LOGS}/n1.log" 2>/dev/null ;;
                3003) tail -5 "${LOGS}/n2.log" 2>/dev/null ;;
                3004) tail -5 "${LOGS}/n3.log" 2>/dev/null ;;
                3005) tail -5 "${LOGS}/g1.log" 2>/dev/null ;;
                3006) tail -5 "${LOGS}/g2.log" 2>/dev/null ;;
                3007) tail -5 "${LOGS}/g3.log" 2>/dev/null ;;
            esac
        fi
    done

    if [ "${RUNNING}" -eq 7 ]; then
        echo "Multi-node network ready: gw=3001, n1=3002, n2=3003, n3=3004, g1=3005, g2=3006, g3=3007"
    else
        echo "ERROR: Only ${RUNNING}/7 nodes started. Check logs in ${LOGS}/"
        exit 1
    fi
    ''',
]

[tasks.check]
description = "Check all code compiles"
command = "cargo"
args = ["check", "--workspace"]

[tasks.fmt]
description = "Format all code"
command = "cargo"
args = ["fmt", "--all"]

[tasks.clippy]
description = "Run clippy on all code"
command = "cargo"
args = ["clippy", "--all-targets"]

[tasks.lint]
description = "Format and lint"
dependencies = ["fmt", "clippy"]

# ─── Rendezvous Service ──────────────────────────────────────────────────────

[tasks.rendezvous-install]
description = "Install rendezvous service dependencies"
cwd = "rendezvous"
script = ["npm install"]

[tasks.test-rendezvous]
description = "Run rendezvous service unit tests"
dependencies = ["rendezvous-install"]
cwd = "rendezvous"
command = "npx"
args = ["vitest", "run"]

[tasks.dev-rendezvous]
description = "Run rendezvous service locally (wrangler dev)"
dependencies = ["rendezvous-install"]
cwd = "rendezvous"
command = "npx"
args = ["wrangler", "dev"]

# ─── Tailwind CSS ─────────────────────────────────────────────────────────────

[tasks.tailwind-install]
description = "Install Tailwind CSS dependencies"
cwd = "ui"
script = ["npm install"]

[tasks.tailwind-build]
description = "Build Tailwind CSS (one-shot)"
cwd = "ui"
script = ["npx @tailwindcss/cli -i ./input.css -o ./assets/tailwind.css"]

[tasks.tailwind-watch]
description = "Watch and rebuild Tailwind CSS on changes"
cwd = "ui"
script = ["npx @tailwindcss/cli -i ./input.css -o ./assets/tailwind.css --watch"]

# ─── E2E Browser Tests ───────────────────────────────────────────────────────

[tasks.e2e-build-rendezvous]
description = "Build UI for E2E rendezvous test (rendezvous URL → local wrangler)"
dependencies = ["tailwind-install", "tailwind-build"]
cwd = "ui"
command = "dx"
args = ["build"]
[tasks.e2e-build-rendezvous.env]
CREAM_RENDEZVOUS_URL = "http://localhost:8787"

[tasks.e2e-serve-rendezvous]
description = "Start UI (8080) and rendezvous service (8787)"
dependencies = ["e2e-build-rendezvous", "restart-rendezvous"]
script = [
    '''
    set -euo pipefail

    # Start UI on port 8080
    nohup python3 -m http.server 8080 --directory ui/target/dx/cream-ui/debug/web/public > /tmp/cream-e2e-server.log 2>&1 &
    echo $! > /tmp/cream-e2e-server.pid

    # Wait for static server to be ready
    for i in $(seq 1 15); do
        if curl -s "http://localhost:8080" > /dev/null 2>&1; then
            echo "Server ready on port 8080"
            break
        fi
        if [ "$i" -eq 15 ]; then
            echo "Timed out waiting for port 8080"
            exit 1
        fi
        sleep 1
    done
    echo "Both servers ready (UI=8080, rendezvous=8787)"
    ''',
]

[tasks.e2e-stop-rendezvous]
description = "Stop rendezvous E2E servers and clean up"
script = [
    '''
    for pidfile in /tmp/cream-e2e-server.pid /tmp/cream-e2e-rendezvous.pid; do
        if [ -f "$pidfile" ]; then
            kill $(cat "$pidfile") 2>/dev/null || true
            rm -f "$pidfile"
        fi
    done
    echo "Rendezvous E2E servers stopped and cleaned up"
    ''',
]

[tasks.test-e2e-rendezvous]
description = "Full E2E rendezvous pipeline: contracts → network → integration tests → UI build → 2 servers → Playwright → cleanup"
dependencies = ["build-contracts-dev", "test-node", "e2e-install", "e2e-serve-rendezvous"]
script = [
    '''
    cleanup() {
        for pidfile in /tmp/cream-e2e-server.pid /tmp/cream-e2e-rendezvous.pid; do
            if [ -f "$pidfile" ]; then
                kill $(cat "$pidfile") 2>/dev/null || true
                rm -f "$pidfile"
            fi
        done
    }
    trap cleanup EXIT
    cd tests/e2e && npx playwright test --project rendezvous
    ''',
]

[tasks.e2e-install]
description = "Install Playwright and browser dependencies"
cwd = "tests/e2e"
script = ["npm install", "npx playwright install chromium"]

[tasks.e2e-build]
description = "Build UI with dx for E2E testing"
dependencies = ["tailwind-install", "tailwind-build"]
cwd = "ui"
command = "dx"
args = ["build"]

[tasks.e2e-serve]
description = "Serve pre-built UI assets on port 8080 for E2E tests"
dependencies = ["e2e-build"]
script = [
    "nohup python3 -m http.server 8080 --directory ui/target/dx/cream-ui/debug/web/public > /tmp/cream-e2e-server.log 2>&1 &",
    "echo $! > /tmp/cream-e2e-server.pid",
    "for i in $(seq 1 10); do curl -s http://localhost:8080 > /dev/null 2>&1 && echo 'Static server ready on port 8080' && exit 0; sleep 1; done",
    "echo 'Timed out waiting for static server' && exit 1",
]

[tasks.e2e-stop]
description = "Stop the E2E static server"
script = [
    "if [ -f /tmp/cream-e2e-server.pid ]; then kill $(cat /tmp/cream-e2e-server.pid) 2>/dev/null || true; rm -f /tmp/cream-e2e-server.pid; echo 'Static server stopped'; else echo 'No server PID file found'; fi",
]

[tasks.e2e]
description = "Run E2E tests (assumes fixture is already running)"
dependencies = ["e2e-install"]
cwd = "tests/e2e"
command = "npx"
args = ["playwright", "test"]

[tasks.test-e2e]
description = "Full E2E pipeline: build contracts, reset node, start server, run tests, stop server"
dependencies = ["build-contracts-dev", "test-node", "e2e-install", "e2e-serve"]
script = [
    '''
    cleanup() {
        if [ -f /tmp/cream-e2e-server.pid ]; then
            kill $(cat /tmp/cream-e2e-server.pid) 2>/dev/null || true
            rm -f /tmp/cream-e2e-server.pid
            echo "Static server stopped"
        fi
    }
    trap cleanup EXIT
    cd tests/e2e && npx playwright test
    ''',
]

# ─── FROST Share Resharing Tests ──────────────────────────────────────────────

[tasks.test-refresh]
description = "Test proactive FROST share refresh: DKG → sign → refresh → sign → verify same group key"
dependencies = ["build-guardian"]
script = [
    '''
    set -euo pipefail
    KEYS_BASE="${HOME}/.cache/freenet"
    LOGS_DIR="${KEYS_BASE}/logs"
    mkdir -p "${LOGS_DIR}"

    GUARDIAN_BIN="./target/debug/cream-guardian"

    # Clear previous DKG keys
    rm -rf "${KEYS_BASE}/guardian-1" "${KEYS_BASE}/guardian-2" "${KEYS_BASE}/guardian-3"

    PEERS_1="http://localhost:3010,http://localhost:3012"
    PEERS_2="http://localhost:3010,http://localhost:3012"
    PEERS_3="http://localhost:3010,http://localhost:3011"

    # Correct peer lists (each guardian gets the other two)
    PEERS_1="http://localhost:3011,http://localhost:3012"
    PEERS_2="http://localhost:3010,http://localhost:3012"
    PEERS_3="http://localhost:3010,http://localhost:3011"

    echo "=== Phase 1: DKG ==="
    PIDS=""
    for i in 1 2 3; do
        PORT=$((3009 + i))
        eval "PEERS=\$PEERS_${i}"
        : > "${LOGS_DIR}/guardian-${i}.log"
        nohup "${GUARDIAN_BIN}" --share-index "${i}" --port "${PORT}" --peers "${PEERS}" \
            >> "${LOGS_DIR}/guardian-${i}.log" 2>&1 &
        PIDS="${PIDS} $!"
    done

    # Wait for DKG to complete
    for i in 1 2 3; do
        PORT=$((3009 + i))
        for attempt in $(seq 1 30); do
            HEALTH=$(curl -s "http://localhost:${PORT}/health" 2>/dev/null || echo "")
            if echo "${HEALTH}" | grep -q '"ready":true'; then
                echo "Guardian ${i} DKG complete"
                break
            fi
            if [ "${attempt}" -eq 30 ]; then
                echo "ERROR: Guardian ${i} DKG timed out"
                cat "${LOGS_DIR}/guardian-${i}.log" 2>/dev/null | tail -10
                kill ${PIDS} 2>/dev/null || true
                exit 1
            fi
            sleep 1
        done
    done

    # Save initial verifying key (group public key — preserved across refresh)
    INITIAL_VK=$(curl -s "http://localhost:3010/public-key" | python3 -c "import sys,json; print(json.dumps(json.load(sys.stdin)['verifying_key']))")
    echo "Initial verifying key: ${INITIAL_VK:0:60}..."

    # Stop guardians
    kill ${PIDS} 2>/dev/null || true
    sleep 2

    echo "=== Phase 2: Refresh ==="
    PIDS=""
    for i in 1 2 3; do
        PORT=$((3009 + i))
        eval "PEERS=\$PEERS_${i}"
        : > "${LOGS_DIR}/guardian-${i}.log"
        nohup "${GUARDIAN_BIN}" --share-index "${i}" --port "${PORT}" --peers "${PEERS}" --refresh \
            >> "${LOGS_DIR}/guardian-${i}.log" 2>&1 &
        PIDS="${PIDS} $!"
    done

    # Wait for refresh to complete (ready=true means refresh finished)
    for i in 1 2 3; do
        PORT=$((3009 + i))
        for attempt in $(seq 1 30); do
            HEALTH=$(curl -s "http://localhost:${PORT}/health" 2>/dev/null || echo "")
            if echo "${HEALTH}" | grep -q '"ready":true'; then
                echo "Guardian ${i} refresh complete"
                break
            fi
            if [ "${attempt}" -eq 30 ]; then
                echo "ERROR: Guardian ${i} refresh timed out"
                cat "${LOGS_DIR}/guardian-${i}.log" 2>/dev/null | tail -10
                kill ${PIDS} 2>/dev/null || true
                exit 1
            fi
            sleep 1
        done
    done

    # Verify group verifying key unchanged (verifying_shares rotate, but group key stays)
    REFRESHED_VK=$(curl -s "http://localhost:3010/public-key" | python3 -c "import sys,json; print(json.dumps(json.load(sys.stdin)['verifying_key']))")
    echo "Refreshed verifying key: ${REFRESHED_VK:0:60}..."

    if [ "${INITIAL_VK}" = "${REFRESHED_VK}" ]; then
        echo "SUCCESS: Group verifying key preserved after refresh"
    else
        echo "FAILURE: Group verifying key changed after refresh!"
        kill ${PIDS} 2>/dev/null || true
        exit 1
    fi

    # Verify config endpoint
    CONFIG=$(curl -s "http://localhost:3010/config")
    echo "Config: ${CONFIG}"

    kill ${PIDS} 2>/dev/null || true
    echo "=== test-refresh PASSED ==="
    ''',
]

[tasks.test-redeal]
description = "Test FROST re-deal: 2-of-3 DKG → redeal to 3-of-5 → verify same group key"
dependencies = ["build-guardian"]
script = [
    '''
    set -euo pipefail
    KEYS_BASE="${HOME}/.cache/freenet"
    LOGS_DIR="${KEYS_BASE}/logs"
    mkdir -p "${LOGS_DIR}"

    GUARDIAN_BIN="./target/debug/cream-guardian"

    # Clear all guardian keys
    for i in 1 2 3 4 5; do
        rm -rf "${KEYS_BASE}/guardian-${i}"
    done

    echo "=== Phase 1: Initial 2-of-3 DKG ==="
    PEERS_1="http://localhost:3011,http://localhost:3012"
    PEERS_2="http://localhost:3010,http://localhost:3012"
    PEERS_3="http://localhost:3010,http://localhost:3011"

    PIDS=""
    for i in 1 2 3; do
        PORT=$((3009 + i))
        eval "PEERS=\$PEERS_${i}"
        : > "${LOGS_DIR}/guardian-${i}.log"
        nohup "${GUARDIAN_BIN}" --share-index "${i}" --port "${PORT}" --peers "${PEERS}" \
            >> "${LOGS_DIR}/guardian-${i}.log" 2>&1 &
        PIDS="${PIDS} $!"
    done

    for i in 1 2 3; do
        PORT=$((3009 + i))
        for attempt in $(seq 1 30); do
            HEALTH=$(curl -s "http://localhost:${PORT}/health" 2>/dev/null || echo "")
            if echo "${HEALTH}" | grep -q '"ready":true'; then
                echo "Guardian ${i} DKG complete"
                break
            fi
            if [ "${attempt}" -eq 30 ]; then
                echo "ERROR: Guardian ${i} DKG timed out"
                kill ${PIDS} 2>/dev/null || true
                exit 1
            fi
            sleep 1
        done
    done

    INITIAL_VK=$(curl -s "http://localhost:3010/public-key" | python3 -c "import sys,json; print(json.dumps(json.load(sys.stdin)['verifying_key']))")
    echo "Initial verifying key (2-of-3): ${INITIAL_VK:0:60}..."

    # Stop original guardians
    kill ${PIDS} 2>/dev/null || true
    sleep 2

    echo "=== Phase 2: Start 5 guardians for re-deal ==="
    # Start all 5 guardians (1-3 have keys, 4-5 are new and will wait for redeal/receive)
    PIDS=""
    for i in 1 2 3; do
        PORT=$((3009 + i))
        : > "${LOGS_DIR}/guardian-${i}.log"
        nohup "${GUARDIAN_BIN}" --share-index "${i}" --port "${PORT}" \
            >> "${LOGS_DIR}/guardian-${i}.log" 2>&1 &
        PIDS="${PIDS} $!"
    done

    # New guardians (no keys, no peers — just listen for redeal/receive)
    for i in 4 5; do
        PORT=$((3009 + i))
        : > "${LOGS_DIR}/guardian-${i}.log"
        nohup "${GUARDIAN_BIN}" --share-index "${i}" --port "${PORT}" \
            >> "${LOGS_DIR}/guardian-${i}.log" 2>&1 &
        PIDS="${PIDS} $!"
    done

    # Wait for 1-3 to be ready (loaded from disk) and 4-5 to be healthy
    for i in 1 2 3; do
        PORT=$((3009 + i))
        for attempt in $(seq 1 15); do
            HEALTH=$(curl -s "http://localhost:${PORT}/health" 2>/dev/null || echo "")
            if echo "${HEALTH}" | grep -q '"ready":true'; then
                echo "Guardian ${i} ready (loaded keys)"
                break
            fi
            sleep 1
        done
    done

    for i in 4 5; do
        PORT=$((3009 + i))
        for attempt in $(seq 1 15); do
            if curl -s "http://localhost:${PORT}/health" > /dev/null 2>&1; then
                echo "Guardian ${i} listening"
                break
            fi
            sleep 1
        done
    done

    echo "=== Phase 3: Re-deal from 2-of-3 to 3-of-5 ==="
    # Guardian 1 acts as coordinator
    # Stop guardian 1, restart with --redeal
    OLD_G1_PID=$(echo ${PIDS} | awk '{print $1}')
    kill ${OLD_G1_PID} 2>/dev/null || true
    sleep 1

    # New peers for 3-of-5 (all except guardian 1)
    NEW_PEERS="http://localhost:3011,http://localhost:3012,http://localhost:3013,http://localhost:3014"
    OLD_PEERS="http://localhost:3011,http://localhost:3012"

    : > "${LOGS_DIR}/guardian-1.log"
    nohup "${GUARDIAN_BIN}" --share-index 1 --port 3010 \
        --redeal \
        --old-peers "${OLD_PEERS}" \
        --peers "${NEW_PEERS}" \
        --new-max-signers 5 \
        --new-min-signers 3 \
        >> "${LOGS_DIR}/guardian-1.log" 2>&1 &
    REDEAL_PID=$!

    # Wait for all 5 to be ready after redeal
    for i in 1 2 3 4 5; do
        PORT=$((3009 + i))
        for attempt in $(seq 1 60); do
            HEALTH=$(curl -s "http://localhost:${PORT}/health" 2>/dev/null || echo "")
            if echo "${HEALTH}" | grep -q '"ready":true'; then
                echo "Guardian ${i} ready after redeal"
                break
            fi
            if [ "${attempt}" -eq 60 ]; then
                echo "ERROR: Guardian ${i} not ready after redeal"
                cat "${LOGS_DIR}/guardian-${i}.log" 2>/dev/null | tail -20
                kill ${PIDS} ${REDEAL_PID} 2>/dev/null || true
                exit 1
            fi
            sleep 1
        done
    done

    # Verify group verifying key unchanged
    REDEALT_VK=$(curl -s "http://localhost:3010/public-key" | python3 -c "import sys,json; print(json.dumps(json.load(sys.stdin)['verifying_key']))")
    echo "Re-dealt verifying key (3-of-5): ${REDEALT_VK:0:60}..."

    if [ "${INITIAL_VK}" = "${REDEALT_VK}" ]; then
        echo "SUCCESS: Group verifying key preserved after redeal"
    else
        echo "FAILURE: Group verifying key changed after redeal!"
        kill ${PIDS} ${REDEAL_PID} 2>/dev/null || true
        exit 1
    fi

    # Verify new config
    CONFIG=$(curl -s "http://localhost:3010/config")
    echo "New config: ${CONFIG}"
    if echo "${CONFIG}" | grep -q '"min_signers":3' && echo "${CONFIG}" | grep -q '"max_signers":5'; then
        echo "SUCCESS: Config updated to 3-of-5"
    else
        echo "FAILURE: Config not updated correctly"
        kill ${PIDS} ${REDEAL_PID} 2>/dev/null || true
        exit 1
    fi

    kill ${PIDS} ${REDEAL_PID} 2>/dev/null || true
    echo "=== test-redeal PASSED ==="
    ''',
]
